<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Search · MLJ</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLJ</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><a class="toctext" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li class="current"><a class="toctext" href>Model Search</a><ul class="internal"></ul></li><li><a class="toctext" href="../machines/">Machines</a></li><li><a class="toctext" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="toctext" href="../performance_measures/">Performance Measures</a></li><li><a class="toctext" href="../tuning_models/">Tuning Models</a></li><li><a class="toctext" href="../learning_curves/">Learning Curves</a></li><li><a class="toctext" href="../built_in_transformers/">Built-in Transformers</a></li><li><a class="toctext" href="../composing_models/">Composing Models</a></li><li><a class="toctext" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="toctext" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="toctext" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="toctext" href="../benchmarking/">Benchmarking</a></li><li><a class="toctext" href="../working_with_tasks/">Working with Tasks</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li><li><a class="toctext" href="../api/">API</a></li><li><a class="toctext" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="toctext" href="../NEWS/">MLJ News</a></li><li><a class="toctext" href="../frequently_asked_questions/">FAQ</a></li><li><a class="toctext" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="toctext" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Model Search</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/model_search.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Model Search</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Model-Search-1" href="#Model-Search-1">Model Search</a></h1><p>MLJ has a model registry, allowing the user to search models and their properties, without loading all the packages containing model code. In turn, this allows one to efficiently find all models solving a given machine learning task. The task itself is specified with the help of the <code>matching</code> method, and the search executed with the <code>models</code> methods, as detailed below.</p><h3><a class="nav-anchor" id="Model-metadata-1" href="#Model-metadata-1">Model metadata</a></h3><p><em>Terminology.</em> In this section the word &quot;model&quot; refers to the metadata entry in the registry of an actual model <code>struct</code>, as appearing elsewhere in the manual. One can obtain such an entry with the <code>info</code> command:</p><div></div><pre><code class="language-julia-repl">julia&gt; info(&quot;PCA&quot;)
Principal component analysis. Learns a linear transformation to project the data  on a lower dimensional space while preserving most of the initial variance.
→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).
→ do `@load PCA pkg=&quot;MultivariateStats&quot;` to use the model.
→ do `?PCA` for documentation.
(name = &quot;PCA&quot;,
 package_name = &quot;MultivariateStats&quot;,
 is_supervised = false,
 docstring = &quot;Principal component analysis. Learns a linear transformation to project the data  on a lower dimensional space while preserving most of the initial variance.\n→ based on [MultivariateStats](https://github.com/JuliaStats/MultivariateStats.jl).\n→ do `@load PCA pkg=\&quot;MultivariateStats\&quot;` to use the model.\n→ do `?PCA` for documentation.&quot;,
 hyperparameter_types = [&quot;Union{Nothing, Int64}&quot;, &quot;Symbol&quot;, &quot;Float64&quot;, &quot;Union{Nothing, Array{Float64,1}, Real}&quot;],
 hyperparameters = Symbol[:maxoutdim, :method, :pratio, :mean],
 implemented_methods = Symbol[:fit, :fitted_params, :transform],
 is_pure_julia = true,
 is_wrapper = false,
 load_path = &quot;MLJModels.MultivariateStats_.PCA&quot;,
 package_license = &quot;MIT&quot;,
 package_url = &quot;https://github.com/JuliaStats/MultivariateStats.jl&quot;,
 package_uuid = &quot;6f286f6a-111f-5878-ab1e-185364afe411&quot;,
 supports_online = false,
 input_scitype = Table{_s13} where _s13&lt;:(AbstractArray{_s12,1} where _s12&lt;:Continuous),
 output_scitype = Unknown,)</code></pre><p>If two models with the same name occur in different packages, the package name must be specified, as in <code>info(&quot;LinearRegressor&quot;, pkg=&quot;GLM&quot;)</code>.</p><h3><a class="nav-anchor" id="General-model-queries-1" href="#General-model-queries-1">General model queries</a></h3><p>We list all models with <code>models()</code>, and list the models for which code is  already loaded with <code>localmodels()</code>:</p><pre><code class="language-julia-repl">julia&gt; localmodels()
11-element Array{NamedTuple,1}:
 (name = ConstantClassifier, package_name = MLJModels, ... )
 (name = ConstantRegressor, package_name = MLJModels, ... )
 (name = DeterministicConstantClassifier, package_name = MLJModels, ... )
 (name = DeterministicConstantRegressor, package_name = MLJModels, ... )
 (name = FeatureSelector, package_name = MLJModels, ... )
 (name = FillImputer, package_name = MLJModels, ... )
 (name = OneHotEncoder, package_name = MLJModels, ... )
 (name = Standardizer, package_name = MLJModels, ... )
 (name = UnivariateBoxCoxTransformer, package_name = MLJModels, ... )
 (name = UnivariateDiscretizer, package_name = MLJModels, ... )
 (name = UnivariateStandardizer, package_name = MLJModels, ... )

julia&gt; localmodels()[2]
Constant regressor (Probabilistic).
→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).
→ do `@load ConstantRegressor pkg=&quot;MLJModels&quot;` to use the model.
→ do `?ConstantRegressor` for documentation.
(name = &quot;ConstantRegressor&quot;,
 package_name = &quot;MLJModels&quot;,
 is_supervised = true,
 docstring = &quot;Constant regressor (Probabilistic).\n→ based on [MLJModels](https://github.com/alan-turing-institute/MLJModels.jl).\n→ do `@load ConstantRegressor pkg=\&quot;MLJModels\&quot;` to use the model.\n→ do `?ConstantRegressor` for documentation.&quot;,
 hyperparameter_types = [&quot;Type{D} where D&quot;],
 hyperparameters = Symbol[:distribution_type],
 implemented_methods = Symbol[:fit, :predict, :fitted_params],
 is_pure_julia = true,
 is_wrapper = false,
 load_path = &quot;MLJModels.ConstantRegressor&quot;,
 package_license = &quot;MIT&quot;,
 package_url = &quot;https://github.com/alan-turing-institute/MLJModels.jl&quot;,
 package_uuid = &quot;d491faf4-2d78-11e9-2867-c94bc002c0b7&quot;,
 prediction_type = :probabilistic,
 supports_online = false,
 supports_weights = false,
 input_scitype = Table{_s13} where _s13&lt;:(AbstractArray{_s12,1} where _s12&lt;:Union{Missing, Found}),
 target_scitype = AbstractArray{Continuous,1},)</code></pre><p>If <code>models</code> is passed any <code>Bool</code>-valued function <code>test</code>, it returns every <code>model</code> for which <code>test(model)</code> is true, as in </p><pre><code class="language-julia-repl">julia&gt; test(model) = model.is_supervised &amp;&amp;
                       MLJ.Table(Continuous) &lt;: model.input_scitype &amp;&amp;
                       AbstractVector{&lt;:Multiclass{3}} &lt;: model.target_scitype &amp;&amp;
                       model.prediction_type == :deterministic
test (generic function with 1 method)

julia&gt; models(test)
13-element Array{NamedTuple,1}:
 (name = DeterministicConstantClassifier, package_name = MLJModels, ... )
 (name = LinearSVC, package_name = LIBSVM, ... )
 (name = NuSVC, package_name = LIBSVM, ... )
 (name = PassiveAggressiveClassifier, package_name = ScikitLearn, ... )
 (name = PerceptronClassifier, package_name = ScikitLearn, ... )
 (name = RandomForestRegressor, package_name = ScikitLearn, ... )
 (name = RidgeCVClassifier, package_name = ScikitLearn, ... )
 (name = RidgeClassifier, package_name = ScikitLearn, ... )
 (name = SGDClassifier, package_name = ScikitLearn, ... )
 (name = SVC, package_name = LIBSVM, ... )
 (name = SVMClassifier, package_name = ScikitLearn, ... )
 (name = SVMLClassifier, package_name = ScikitLearn, ... )
 (name = SVMNuClassifier, package_name = ScikitLearn, ... )</code></pre><p>Multiple test arguments may be passed to <code>models</code>, which are applied conjunctively.</p><h3><a class="nav-anchor" id="Matching-models-to-data-1" href="#Matching-models-to-data-1">Matching models to data</a></h3><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>matching</code> method described below is experimental and may break in subsequent MLJ releases.</p></div></div><p>Common searches are streamlined with the help of the <code>matching</code> command, defined as follows:</p><ul><li><code>matching(model, X, y) == true</code> exactly when <code>model</code> is supervised  and admits inputs and targets with the scientific types of <code>X</code> and  <code>y</code>, respectively</li><li><code>matching(model, X) == true</code> exactly when <code>model</code> is unsupervised  and admits inputs with the scientific types of <code>X</code>.</li></ul><p>So, to search for all supervised probablistic models handling input <code>X</code> and target <code>y</code>, one can define the testing function <code>task</code> by</p><pre><code class="language-julia">task(model) = matching(model, X, y)) &amp;&amp; model.is_probabilistic</code></pre><p>And execute the search with</p><pre><code class="language-julia">models(task)</code></pre><p>Also defined are <code>Bool</code>-valued callable objects <code>matching(model)</code>, <code>matching(X, y)</code> and <code>matching(X)</code>, with obvious behaviour. For example,  <code>matching(X, y)(model) = matching(model, X, y)</code>. </p><p>So, to search for all models compatible with input <code>X</code> and target <code>y</code>, for example, one executes</p><pre><code class="language-julia">models(matching(X, y))</code></pre><p>while the preceding search can also be written</p><pre><code class="language-julia">models() do model
    matching(model, X, y) &amp;&amp;
    model.prediction_type == :probabilistic
end</code></pre><h3><a class="nav-anchor" id="API-1" href="#API-1">API</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJBase.models" href="#MLJBase.models"><code>MLJBase.models</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">models()</code></pre><p>List all models in the MLJ registry. Here and below <em>model</em> means the registry metadata entry for a genuine model type (a proxy for types whose defining code may not be loaded).</p><pre><code class="language-none">models(conditions...)</code></pre><p>List all models satisifying the specified <code>conditions</code>. A <em>condition</em> is any <code>Bool</code>-valued function on models.</p><p>Excluded in the listings are the built-in model-wraps <code>EnsembleModel</code>, <code>TunedModel</code>, and <code>IteratedModel</code>.</p><p><strong>Example</strong></p><p>If</p><pre><code class="language-none">task(model) = model.is_supervised &amp;&amp; model.is_probabilistic</code></pre><p>then <code>models(task)</code> lists all supervised models making probabilistic predictions.</p><p>See also: <a href="#MLJModels.localmodels"><code>localmodels</code></a>.</p></div></div><div><div><pre><code class="language-none">models(N::AbstractNode)</code></pre><p>A vector of all models referenced by a node <code>N</code>, each model appearing exactly once.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.localmodels" href="#MLJModels.localmodels"><code>MLJModels.localmodels</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">localmodels(; modl=Main)
localmodels(conditions...; modl=Main)</code></pre><p>List all models whose names are in the namespace of the specified module <code>modl</code>, or meeting the <code>conditions</code>, if specified. Here a <em>condition</em> is a <code>Bool</code>-valued function on models.</p><p>See also <a href="@ref">models</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJ.matching" href="#MLJ.matching"><code>MLJ.matching</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>matching(model, X, y)</p><p>Returns <code>true</code> exactly when the registry metadata entry <code>model</code> is supervised and admits inputs and targets with the scientific types of <code>X</code> and <code>y</code>, respectively.</p><p>matching(model, X)</p><p>Returns <code>true</code> exactly when <code>model</code> is unsupervised and admits inputs with the scientific types of <code>X</code>.</p><pre><code class="language-none">matching(model), matching(X, y), matching(X)</code></pre><p>Curried versions of the preceding methods, i.e., <code>Bool</code>-valued callable objects satisfying <code>matching(X, y)(model) = matching(model, X, y)</code>, etc.</p><p><strong>Example</strong></p><pre><code class="language-none">models(matching(X))</code></pre><p>Finds all unsupervised models compatible with input data <code>X</code>.</p><pre><code class="language-none">models() do model
    matching(model, X, y) &amp;&amp; model.prediction_type == :probabilistic
end</code></pre><p>Finds all supervised models compatible with input data <code>X</code> and target data <code>y</code> and making probabilistic predictions.</p><p>See also <a href="#MLJBase.models"><code>models</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/a7084d2545a38a6b8f97cb7200024ecf29563745/src/model_matching.jl#L67-L101">source</a></section><footer><hr/><a class="previous" href="../common_mlj_workflows/"><span class="direction">Previous</span><span class="title">Common MLJ Workflows</span></a><a class="next" href="../machines/"><span class="direction">Next</span><span class="title">Machines</span></a></footer></article></body></html>
