<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Simplified Model API · MLJ</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLJ</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../scientific_data_types/">Scientific Data Types</a></li><li><span class="toctext">Adding New Models</span><ul><li><a class="toctext" href="../adding_new_models/">Adding New Models</a></li><li class="current"><a class="toctext" href>The Simplified Model API</a><ul class="internal"></ul></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li><li><a class="toctext" href="../">API</a></li><li><a class="toctext" href="../frequently_asked_questions/">FAQ</a></li><li><a class="toctext" href="../NEWS/">MLJ News</a></li></ul></nav><article id="docs"><header><nav><ul><li>Adding New Models</li><li><a href>The Simplified Model API</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/the_simplified_model_api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The Simplified Model API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-Simplified-Model-API-1" href="#The-Simplified-Model-API-1">The Simplified Model API</a></h1><p>To quickly implement a new supervised model in MLJ, it suffices to:</p><ul><li>Define a <code>mutable struct</code> to store hyperparameters. This is either a subtype of <code>Probabilistic{Any}</code> or <code>Deterministic{Any}</code>, depending on whether probabilistic or ordinary point predictions are intended. This <code>struct</code> is the <em>model</em>.</li><li>Define a <code>fit</code> method, dispatched on the model, returning learned parameters, also known as the <em>fit-result</em>.</li><li>Define a <code>predict</code> method, dispatched on the model, and passed the fit-result, to return predictions on new patterns.</li></ul><p>In the examples below, the training input <code>X</code> of <code>fit</code>, and the new input <code>Xnew</code> passed to <code>predict</code>, are tables implementing the <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> interface. Each training target <code>y</code> is a <code>Vector</code> for regressors, and a  <code>CategoricalVector</code> for classifiers. The predicitions returned by <code>predict</code> have the same form as <code>y</code> for deterministic models, but are <code>Vector</code>s of distibutions for probabilistic models.</p><p>For your models to implement an optional <code>update</code> method, buy into the MLJ logging protocol, or report training statistics or other model-specific functionality, a <code>fit</code> method with a slightly different signature and output is required. To enable checks of the scientific type of data passed to your model by MLJ&#39;s meta-algorithms, one needs to implement additional traits. A <code>clean!</code> method can be defined to check that hyperparameter values are within normal ranges. For details, see <a href="../adding_new_models/">Adding New Models</a>.</p><h3><a class="nav-anchor" id="A-simple-deterministic-regressor-1" href="#A-simple-deterministic-regressor-1">A simple deterministic regressor</a></h3><p>Here&#39;s a quick-and-dirty implementation of a ridge regressor with no intercept:</p><pre><code class="language-julia">import MLJBase
using LinearAlgebra

mutable struct MyRegressor &lt;: MLJBase.Deterministic{Any}
    lambda::Float64
end

# fit returns coefficients minimizing a penalized rms loss function:
function MLJBase.fit(model::MyRegressor, X, y)
    x = MLJBase.matrix(X)                     # convert table to matrix
    fitresult = (x&#39;x - model.lambda*I)\(x&#39;y)  # the coefficients
    return fitresult
end

# predict uses coefficients to make new prediction:
MLJBase.predict(model::MyRegressor, fitresult, Xnew) = MLJBase.matrix(Xnew)fitresult</code></pre><p>After loading this code, all MLJ&#39;s basic meta-algorithms can be applied to <code>MyRegressor</code>:</p><pre><code class="language-julia">julia&gt; using MLJ
julia&gt; task = load_boston()
julia&gt; model = MyRegressor(1.0)
julia&gt; regressor = machine(model, task)
julia&gt; evaluate!(regressor, resampling=CV(), measure=rms) |&gt; mean
7.434221318358656
</code></pre><h3><a class="nav-anchor" id="A-simple-probabilistic-classifier-1" href="#A-simple-probabilistic-classifier-1">A simple probabilistic classifier</a></h3><p>The following probabilistic model simply fits a probability distribution to a <code>MultiClass</code>training target and returns this pdf for any new pattern:</p><pre><code class="language-julia">import MLJBase
import Tables
import Distributions

struct MyClassifier &lt;: MLJBase.Probabilistic{Any}
end

# `fit` ignores the inputs X and returns the training target y
# probability distribution:
function MLJBase.fit(model::MyClassifier, X, y)
    fitresult = Distributions.fit(MLJBase.UnivariateNominal, y)
    return fitresult
end

# `predict` retunrs the passed fitresult (pdf) for all new patterns:
function MLJBase.predict(model::MyClassifier, fitresult, Xnew)
    row_iterator = Tables.rows(Xnew)
    return [fitresult for r in row_iterator]
end</code></pre><p>For more details on <code>UnivariateNominal</code>, query <code>MLJBase.UnivariateNominal</code>. </p><footer><hr/><a class="previous" href="../adding_new_models/"><span class="direction">Previous</span><span class="title">Adding New Models</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
