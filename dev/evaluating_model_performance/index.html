<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluating Model Performance · MLJ</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLJ</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><a class="toctext" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="toctext" href="../model_search/">Model Search</a></li><li><a class="toctext" href="../machines/">Machines</a></li><li class="current"><a class="toctext" href>Evaluating Model Performance</a><ul class="internal"></ul></li><li><a class="toctext" href="../performance_measures/">Performance Measures</a></li><li><a class="toctext" href="../tuning_models/">Tuning Models</a></li><li><a class="toctext" href="../learning_curves/">Learning Curves</a></li><li><a class="toctext" href="../built_in_transformers/">Built-in Transformers</a></li><li><a class="toctext" href="../composing_models/">Composing Models</a></li><li><a class="toctext" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="toctext" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="toctext" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="toctext" href="../benchmarking/">Benchmarking</a></li><li><a class="toctext" href="../working_with_tasks/">Working with Tasks</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li><li><a class="toctext" href="../api/">API</a></li><li><a class="toctext" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="toctext" href="../NEWS/">MLJ News</a></li><li><a class="toctext" href="../frequently_asked_questions/">FAQ</a></li><li><a class="toctext" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="toctext" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Evaluating Model Performance</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/evaluating_model_performance.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Evaluating Model Performance</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Evaluating-Model-Performance-1" href="#Evaluating-Model-Performance-1">Evaluating Model Performance</a></h1><p>MLJ allows quick evaluation of a supervised model&#39;s performance against a battery of selected losses or scores. For more on available performance measures, see <a href="../performance_measures/">Performance Measures</a>.</p><p>In addition to hold-out and cross-validation, the user can specify their own list of train/test pairs of row indices for resampling, or define their own re-usable resampling strategies.</p><p>For simultaneously evaluating <em>multiple</em> models and/or data sets, see <a href="../benchmarking/">Benchmarking</a>.</p><h3><a class="nav-anchor" id="Evaluating-against-a-single-measure-1" href="#Evaluating-against-a-single-measure-1">Evaluating against a single measure</a></h3><div></div><pre><code class="language-julia-repl">julia&gt; using MLJ

julia&gt; X = (a=rand(12), b=rand(12), c=rand(12));

julia&gt; y = X.a + 2X.b + 0.05*rand(12);

julia&gt; model = @load RidgeRegressor pkg=MultivariateStats
MLJModels.MultivariateStats_.RidgeRegressor(lambda = 1.0,) @ 9…93

julia&gt; cv=CV(nfolds=3)
CV(nfolds = 3,
   shuffle = false,
   rng = MersenneTwister(UInt32[0xa14065be, 0x13c8e071, 0xea450cfc, 0x02abefb9]) @ 596,) @ 8…19

julia&gt; evaluate(model, X, y, resampling=cv, measure=l2, verbosity=0)
(measure = MLJBase.L2[l2],
 measurement = [0.16694483137943847],
 per_fold = Array{Float64,1}[[0.1234459305172518, 0.3283865410652691, 0.04900202255579449]],
 per_observation = Array{Array{Float64,1},1}[[[0.037127876885684336, 0.07610213729284772, 0.08967148802826191, 0.29088221986221324], [0.001068037609230074, 0.13957035438091722, 0.06844804525932821, 1.104459727011601], [0.03578791758559336, 0.02328627355488293, 0.12161073866657163, 0.015323160416130042]]],)</code></pre><p>Alternatively, instead of applying <code>evaluate</code> to a model + data, one may call <code>evaluate!</code> on an existing machine wrapping the model in data:</p><pre><code class="language-julia-repl">julia&gt; mach = machine(model, X, y)
Machine{RidgeRegressor} @ 1…52

julia&gt; evaluate!(mach, resampling=cv, measure=l2, verbosity=0)
(measure = MLJBase.L2[l2],
 measurement = [0.16694483137943847],
 per_fold = Array{Float64,1}[[0.1234459305172518, 0.3283865410652691, 0.04900202255579449]],
 per_observation = Array{Array{Float64,1},1}[[[0.037127876885684336, 0.07610213729284772, 0.08967148802826191, 0.29088221986221324], [0.001068037609230074, 0.13957035438091722, 0.06844804525932821, 1.104459727011601], [0.03578791758559336, 0.02328627355488293, 0.12161073866657163, 0.015323160416130042]]],)</code></pre><p>(The latter call is a mutating call as the learned parameters stored in the machine potentially change. )</p><h3><a class="nav-anchor" id="Multiple-measures-1" href="#Multiple-measures-1">Multiple measures</a></h3><pre><code class="language-julia-repl">julia&gt; evaluate!(mach,
                 resampling=cv,
                 measure=[l1, rms, rmslp1], verbosity=0)
(measure = MLJBase.Measure[l1, rms, rmslp1],
 measurement = [0.3200382548352724, 0.4085888292396629, 0.15587530567969807],
 per_fold = Array{Float64,1}[[0.3268347677776235, 0.42970764159966823, 0.20357235512852545], [0.35134873063276006, 0.5730502081539357, 0.22136400465250552], [0.17651897749850964, 0.18803406332837677, 0.07984719389758528]],
 per_observation = Union{Missing, Array{Array{Float64,1},1}}[Array{Float64,1}[[0.19268595404357924, 0.27586615829573535, 0.2994519795029946, 0.5393349792681847], [0.03268084468354626, 0.3735911593987701, 0.26162577330861003, 1.0509327890077467], [0.1891769478176275, 0.15259840613480513, 0.34872731276252456, 0.12378675379914461]], missing, missing],)</code></pre><h3><a class="nav-anchor" id="Custom-measures-and-weighted-measures-1" href="#Custom-measures-and-weighted-measures-1">Custom measures and weighted measures</a></h3><pre><code class="language-julia-repl">julia&gt; my_loss(yhat, y) = maximum((yhat - y).^2);

julia&gt; my_per_observation_loss(yhat, y) = abs.(yhat - y);

julia&gt; MLJ.reports_each_observation(::typeof(my_per_observation_loss)) = true;

julia&gt; my_weighted_score(yhat, y) = 1/mean(abs.(yhat - y));

julia&gt; my_weighted_score(yhat, y, w) = 1/mean(abs.((yhat - y).^w));

julia&gt; MLJ.supports_weights(::typeof(my_weighted_score)) = true;

julia&gt; MLJ.orientation(::typeof(my_weighted_score)) = :score;

julia&gt; holdout = Holdout(fraction_train=0.8)
Holdout(fraction_train = 0.8,
        shuffle = false,
        rng = MersenneTwister(UInt32[0xa14065be, 0x13c8e071, 0xea450cfc, 0x02abefb9]) @ 596,) @ 8…68

julia&gt; weights = [1, 1, 2, 1, 1, 2, 3, 1, 1, 2, 3, 1];

julia&gt; evaluate!(mach,
                 resampling=CV(nfolds=3),
                 measure=[my_loss, my_per_observation_loss, my_weighted_score, l1],
                 weights=weights, verbosity=0)
┌ Warning: Sample weights ignored in evaluations of the following measures, as unsupported: 
│ my_loss, my_per_observation_loss 
└ @ MLJ ~/build/alan-turing-institute/MLJ.jl/src/resampling.jl:433
(measure = Any[Main.ex-evaluation_of_supervised_models.my_loss, Main.ex-evaluation_of_supervised_models.my_per_observation_loss, Main.ex-evaluation_of_supervised_models.my_weighted_score, l1],
 measurement = [0.5056508951801286, 0.3200382548352724, 5.810338806459479, 0.31092967597369064],
 per_fold = Array{Float64,1}[[0.29088221986221324, 1.104459727011601, 0.12161073866657163], [0.3268347677776235, 0.42970764159966823, 0.20357235512852545], [3.6444524002786722, 3.2229687813556485, 10.563595237744117], [0.3213582101226977, 0.3736676103449519, 0.2377632074534223]],
 per_observation = Union{Missing, Array{Array{Float64,1},1}}[missing, Array{Float64,1}[[0.19268595404357924, 0.27586615829573535, 0.2994519795029946, 0.5393349792681847], [0.03268084468354626, 0.3735911593987701, 0.26162577330861003, 1.0509327890077467], [0.1891769478176275, 0.15259840613480513, 0.34872731276252456, 0.12378675379914461]], missing, Array{Float64,1}[[0.1541487632348634, 0.2206929266365883, 0.4791231672047914, 0.4314679834145478], [0.018674768390597864, 0.42696132502716583, 0.44850132567190293, 0.6005330222901409], [0.1081011130386443, 0.17439817843977728, 0.5978182504500421, 0.0707352878852255]]],)</code></pre><h3><a class="nav-anchor" id="User-specified-train/test-sets-1" href="#User-specified-train/test-sets-1">User-specified train/test sets</a></h3><p>Users can either provide their own list of train/test pairs of row indices for resampling, as in this example:</p><pre><code class="language-julia-repl">julia&gt; fold1 = 1:6; fold2 = 7:12;

julia&gt; evaluate!(mach,
                 resampling = [(fold1, fold2), (fold2, fold1)],
                 measure=[l1, l2], verbosity=0)
(measure = MLJBase.Measure[l1, l2],
 measurement = [0.570775898616815, 0.493063060112814],
 per_fold = Array{Float64,1}[[0.673800833396477, 0.46775096383715303], [0.7337044249303041, 0.2524216952953239]],
 per_observation = Array{Array{Float64,1},1}[[[0.6816823841696855, 1.5975532055086001, 0.31772548868478667, 0.19495039094154998, 1.1071297412243526, 0.14376378984988647], [0.4183188927897914, 0.45941341167410354, 0.18634947864966045, 0.7486343169728116, 0.35637730309118676, 0.6374123798453643]], [[0.46469087288726674, 2.5521762444308034, 0.1009494861599865, 0.038005654928263174, 1.2257362639035019, 0.02066802727200232], [0.174990696064877, 0.21106068282603935, 0.03472612819300026, 0.5604533405493481, 0.1270047821585476, 0.40629454198013093]]],)</code></pre><p>Or define their own re-usable <code>ResamplingStrategy</code> objects, - see <a href="#Custom-resampling-strategies-1">Custom resampling strategies</a> below.</p><h3><a class="nav-anchor" id="Built-in-resampling-strategies-1" href="#Built-in-resampling-strategies-1">Built-in resampling strategies</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJ.Holdout" href="#MLJ.Holdout"><code>MLJ.Holdout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">holdout = Holdout(; fraction_train=0.7,
                     shuffle=nothing,
                     rng=nothing)</code></pre><p>Holdout resampling strategy, for use in <code>evaluate!</code>, <code>evaluate</code> and in tuning.</p><pre><code class="language-none">train_test_pairs(holdout, rows)</code></pre><p>Returns the pair <code>[(train, test)]</code>, where <code>train</code> and <code>test</code> are vectors such that <code>rows=vcat(train, test)</code> and <code>length(train)/length(test)</code> is approximatey equal to fraction_train`.</p><p>Pre-shuffling of <code>rows</code> is controlled by <code>rng</code> and <code>shuffle</code>. If <code>rng</code> is an integer, then the <code>Holdout</code> keyword constructor resets it to <code>MersenneTwister(rng)</code>. Otherwise some <code>AbstractRNG</code> object is expected. </p><p>If <code>rng</code> is left unspecified, <code>rng</code> is reset to <code>Random.GLOBAL_RNG</code>, in which case rows are only pre-shuffled if <code>shuffle=true</code> is specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/38744e4ad53c2b9e74d55d8002b46253fffe3a2e/src/resampling.jl#L39-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJ.CV" href="#MLJ.CV"><code>MLJ.CV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">cv = CV(; nfolds=6,  shuffle=nothing, rng=nothing)</code></pre><p>Cross-validation resampling strategy, for use in <code>evaluate!</code>, <code>evaluate</code> and tuning.</p><pre><code class="language-none">train_test_pairs(cv, rows)</code></pre><p>Returns an <code>nfolds</code>-length iterator of <code>(train, test)</code> pairs of vectors (row indices), where each <code>train</code> and <code>test</code> is a sub-vector of <code>rows</code>. The <code>test</code> vectors are mutually exclusive and exhaust <code>rows</code>. Each <code>train</code> vector is the complement of the corresponding <code>test</code> vector. With no row pre-shuffling, the order of <code>rows</code> is preserved, in the sense that <code>rows</code> coincides precisely with the concatenation of the <code>test</code> vectors, in the order they are generated. All but the last <code>test</code> vector have equal length.</p><p>Pre-shuffling of <code>rows</code> is controlled by <code>rng</code> and <code>shuffle</code>. If <code>rng</code> is an integer, then the <code>CV</code> keyword constructor resets it to <code>MersenneTwister(rng)</code>. Otherwise some <code>AbstractRNG</code> object is expected. </p><p>If <code>rng</code> is left unspecified, <code>rng</code> is reset to <code>Random.GLOBAL_RNG</code>, in which case rows are only pre-shuffled if <code>shuffle=true</code> is explicitly specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/38744e4ad53c2b9e74d55d8002b46253fffe3a2e/src/resampling.jl#L87-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJ.StratifiedCV" href="#MLJ.StratifiedCV"><code>MLJ.StratifiedCV</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">stratified_cv = StratifiedCV(; nfolds=6,
                               shuffle=false,
                               rng=Random.GLOBAL_RNG)</code></pre><p>Stratified cross-validation resampling strategy, for use in <code>evaluate!</code>, <code>evaluate</code> and in tuning. Applies only to classification problems (<code>OrderedFactor</code> or <code>Multiclass</code> targets).</p><pre><code class="language-none">train_test_pairs(stratified_cv, rows, y)</code></pre><p>Returns an <code>nfolds</code>-length iterator of <code>(train, test)</code> pairs of vectors (row indices) where each <code>train</code> and <code>test</code> is a sub-vector of <code>rows</code>. The <code>test</code> vectors are mutually exclusive and exhaust <code>rows</code>. Each <code>train</code> vector is the complement of the corresponding <code>test</code> vector.</p><p>Unlike regular cross-validation, the distribution of the levels of the target <code>y</code> corresponding to each <code>train</code> and <code>test</code> is constrained, as far as possible, to replicate that of <code>y[rows]</code> as a whole.</p><p>Specifically, the data is split into a number of groups on which <code>y</code> is constant, and each individual group is resampled according to the ordinary cross-validation strategy <code>CV(nfolds=nfolds)</code>. To obtain the final <code>(train, test)</code> pairs of row indices, the per-group pairs are collated in such a way that each collated <code>train</code> and <code>test</code> respects the original order of <code>rows</code> (after shuffling, if <code>shuffle=true</code>).</p><p>Pre-shuffling of <code>rows</code> is controlled by <code>rng</code> and <code>shuffle</code>. If <code>rng</code> is an integer, then the <code>StratifedCV</code> keyword constructor resets it to <code>MersenneTwister(rng)</code>. Otherwise some <code>AbstractRNG</code> object is expected. </p><p>If <code>rng</code> is left unspecified, <code>rng</code> is reset to <code>Random.GLOBAL_RNG</code>, in which case rows are only pre-shuffled if <code>shuffle=true</code> is explicitly specified.</p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/38744e4ad53c2b9e74d55d8002b46253fffe3a2e/src/resampling.jl#L157-L194">source</a></section><h3><a class="nav-anchor" id="Custom-resampling-strategies-1" href="#Custom-resampling-strategies-1">Custom resampling strategies</a></h3><p>To define your own resampling strategy, make relevant parameters of your strategy the fields of a new type <code>MyResamplingStrategy &lt;: MLJ.ResamplingStrategy</code>, and implement one of the following methods:</p><pre><code class="language-julia">MLJ.train_test_pairs(my_strategy::MyResamplingStrategy, rows)
MLJ.train_test_pairs(my_strategy::MyResamplingStrategy, rows, y)
MLJ.train_test_pairs(my_strategy::MyResamplingStrategy, rows, X, y)</code></pre><p>Each method takes a vector of indices <code>rows</code> and return a vector <code>[(t1, e1), (t2, e2), ... (tk, ek)]</code> of train/test pairs of row indices selected from <code>rows</code>. Here <code>X</code>, <code>y</code> are the input and target data (ignored in simple strategies, such as <code>Holdout</code> and <code>CV</code>).</p><p>Here is the code for the <code>Holdout</code> strategy as an example:</p><pre><code class="language-julia">struct Holdout &lt;: ResamplingStrategy
    fraction_train::Float64
    shuffle::Bool
    rng::Union{Int,AbstractRNG}

    function Holdout(fraction_train, shuffle, rng)
        0 &lt; fraction_train &lt; 1 ||
            error(&quot;`fraction_train` must be between 0 and 1.&quot;)
        return new(fraction_train, shuffle, rng)
    end
end

# Keyword Constructor
function Holdout(; fraction_train::Float64=0.7, shuffle=nothing, rng=nothing)
    if rng isa Integer
        rng = MersenneTwister(rng)
    end
    if shuffle === nothing
        shuffle = ifelse(rng===nothing, false, true)
    end
    if rng === nothing
        rng = Random.GLOBAL_RNG
    end
    return Holdout(fraction_train, shuffle, rng)
end

function train_test_pairs(holdout::Holdout, rows)
    train, test = partition(rows, holdout.fraction_train,
                          shuffle=holdout.shuffle, rng=holdout.rng)
    return [(train, test),]
end</code></pre><h3><a class="nav-anchor" id="API-1" href="#API-1">API</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJ.evaluate!" href="#MLJ.evaluate!"><code>MLJ.evaluate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate!(mach,
          resampling=CV(),
          measure=nothing,
          weights=nothing,
          operation=predict,
          acceleration=DEFAULT_RESOURCE[],
          force=false,
          verbosity=1)</code></pre><p>Estimate the performance of a machine <code>mach</code> wrapping a supervised model in data, using the specified <code>resampling</code> strategy (defaulting to 6-fold cross-validation) and <code>measure</code>, which can be a single measure or vector.</p><p>Do <code>subtypes(MLJ.ResamplingStrategy)</code> to obtain a list of available resampling strategies. If <code>resampling</code> is not an object of type <code>MLJ.ResamplingStrategy</code>, then a vector of pairs (of the form <code>(train_rows, test_rows)</code> is expected. For example, setting</p><pre><code class="language-none">resampling = [(1:100), (101:200)),
               (101:200), (1:100)]</code></pre><p>gives two-fold cross-validation using the first 200 rows of data.</p><p>If <code>resampling isa MLJ.ResamplingStrategy</code> then one may optionally restrict the data used in evaluation by specifying <code>rows</code>.</p><p>An optional <code>weights</code> vector may be passed for measures that support sample weights (<code>MLJ.supports_weights(measure) == true</code>), which is ignored by those that don&#39;t.</p><p><em>Important:</em> If <code>mach</code> already wraps sample weights <code>w</code> (as in <code>mach = machine(model, X, y, w)</code>) then these weights, which are used for <em>training</em>, are automatically passed to the measures for evaluation. However, for evaluation purposes, any <code>weights</code> specified as a keyword argument will take precedence over <code>w</code>.</p><p>User-defined measures are supported; see the manual for details.</p><p>If no measure is specified, then <code>default_measure(mach.model)</code> is used, unless this default is <code>nothing</code> and an error is thrown.</p><p>The <code>acceleration</code> keyword argument is used to specify the compute resource (a subtype of <code>ComputationalResources.AbstractResource</code>) that will be used to accelerate/parallelize the resampling operation.</p><p>Although evaluate! is mutating, <code>mach.model</code> and <code>mach.args</code> are untouched.</p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/38744e4ad53c2b9e74d55d8002b46253fffe3a2e/src/resampling.jl#L354-L404">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJBase.evaluate" href="#MLJBase.evaluate"><code>MLJBase.evaluate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evaluate(model, X, y; measure=nothing, options...)
evaluate(model, X, y, w; measure=nothing, options...)</code></pre><p>Evaluate the performance of a supervised model <code>model</code> on input data <code>X</code> and target <code>y</code>, optionally specifying sample weights <code>w</code> for training, where supported. The same weights are passed to measures that support sample weights, unless this behaviour is overridden by explicitly specifying the option <code>weights=...</code>.</p><p>See the machine version <code>evaluate!</code> for the complete list of options.</p></div></div><a class="source-link" target="_blank" href="https://github.com/alan-turing-institute/MLJ.jl/blob/38744e4ad53c2b9e74d55d8002b46253fffe3a2e/src/resampling.jl#L443-L455">source</a></section><footer><hr/><a class="previous" href="../machines/"><span class="direction">Previous</span><span class="title">Machines</span></a><a class="next" href="../performance_measures/"><span class="direction">Next</span><span class="title">Performance Measures</span></a></footer></article></body></html>
