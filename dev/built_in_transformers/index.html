<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in Transformers · MLJ</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MLJ</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Getting Started</a></li><li><a class="toctext" href="../common_mlj_workflows/">Common MLJ Workflows</a></li><li><a class="toctext" href="../model_search/">Model Search</a></li><li><a class="toctext" href="../machines/">Machines</a></li><li><a class="toctext" href="../evaluating_model_performance/">Evaluating Model Performance</a></li><li><a class="toctext" href="../performance_measures/">Performance Measures</a></li><li><a class="toctext" href="../tuning_models/">Tuning Models</a></li><li class="current"><a class="toctext" href>Built-in Transformers</a><ul class="internal"></ul></li><li><a class="toctext" href="../composing_models/">Composing Models</a></li><li><a class="toctext" href="../homogeneous_ensembles/">Homogeneous Ensembles</a></li><li><a class="toctext" href="../simple_user_defined_models/">Simple User Defined Models</a></li><li><a class="toctext" href="../adding_models_for_general_use/">Adding Models for General Use</a></li><li><a class="toctext" href="../benchmarking/">Benchmarking</a></li><li><a class="toctext" href="../working_with_tasks/">Working with Tasks</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../glossary/">Glossary</a></li><li><a class="toctext" href="../api/">API</a></li><li><a class="toctext" href="../mlj_cheatsheet/">MLJ Cheatsheet</a></li><li><a class="toctext" href="../NEWS/">MLJ News</a></li><li><a class="toctext" href="../frequently_asked_questions/">FAQ</a></li><li><a class="toctext" href="../julia_blogpost/">Julia BlogPost</a></li><li><a class="toctext" href="../acceleration_and_parallelism/">Acceleration and Parallelism</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Built-in Transformers</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/MLJ.jl/blob/master/docs/src/built_in_transformers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Built-in Transformers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Built-in-Transformers-1" href="#Built-in-Transformers-1">Built-in Transformers</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.UnivariateStandardizer" href="#MLJModels.UnivariateStandardizer"><code>MLJModels.UnivariateStandardizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>UnivariateStandardizer()</p><p>Unsupervised model for standardizing (whitening) univariate data.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.Standardizer" href="#MLJModels.Standardizer"><code>MLJModels.Standardizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Standardizer(; features=Symbol[])</p><p>Unsupervised model for standardizing (whitening) the columns of tabular data. If <code>features</code> is empty then all columns <code>v</code> for which all elements have <code>Continuous</code> scitypes are standardized. For different behaviour (e.g. standardizing counts as well), specify the names of features to be standardized.</p><pre><code class="language-none">using DataFrames
X = DataFrame(x1=[0.2, 0.3, 1.0], x2=[4, 2, 3])
stand_model = Standardizer()
transform(fit!(machine(stand_model, X)), X)

3×2 DataFrame
│ Row │ x1        │ x2    │
│     │ Float64   │ Int64 │
├─────┼───────────┼───────┤
│ 1   │ -0.688247 │ 4     │
│ 2   │ -0.458831 │ 2     │
│ 3   │ 1.14708   │ 3     │</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.OneHotEncoder" href="#MLJModels.OneHotEncoder"><code>MLJModels.OneHotEncoder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>OneHotEncoder(; features=Symbol[], drop<em>last=false, ordered</em>factor=true)</p><p>Unsupervised model for one-hot encoding all features of <code>Finite</code> scitype, within some table. If <code>ordered_factor=false</code> then only <code>Multiclass</code> features are considered. The features encoded is further restricted to those in <code>features</code>, when specified and non-empty.</p><p>If <code>drop_last</code> is true, the column for the last level of each categorical feature is dropped. New data to be transformed may lack features present in the fit data, but no new features can be present.</p><p><em>Warning:</em> This transformer assumes that the elements of a categorical  feature in new data to be transformed point to the same  CategoricalPool object encountered during the fit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.FeatureSelector" href="#MLJModels.FeatureSelector"><code>MLJModels.FeatureSelector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FeatureSelector(features=Symbol[])</p><p>An unsupervised model for filtering features (columns) of a table. Only those features encountered during fitting will appear in transformed tables if <code>features</code> is empty (the default). Alternatively, if a non-empty <code>features</code> is specified, then only the specified features are used. Throws an error if a recorded or specified feature is not present in the transformation input.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.UnivariateBoxCoxTransformer" href="#MLJModels.UnivariateBoxCoxTransformer"><code>MLJModels.UnivariateBoxCoxTransformer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>UnivariateBoxCoxTransformer(; n=171, shift=false)</p><p>Unsupervised model specifying a univariate Box-Cox transformation of a single variable taking non-negative values, with a possible preliminary shift. Such a transformation is of the form</p><pre><code class="language-none">x -&gt; ((x + c)^λ - 1)/λ for λ not 0
x -&gt; log(x + c) for λ = 0</code></pre><p>On fitting to data <code>n</code> different values of the Box-Cox exponent λ (between <code>-0.4</code> and <code>3</code>) are searched to fix the value maximizing normality. If <code>shift=true</code> and zero values are encountered in the data then the transformation sought includes a preliminary positive shift <code>c</code> of <code>0.2</code> times the data mean. If there are no zero values, then no shift is applied.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.UnivariateDiscretizer" href="#MLJModels.UnivariateDiscretizer"><code>MLJModels.UnivariateDiscretizer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>UnivariateDiscretizer(n_classes=512)</p><p>Returns an <code>MLJModel</code> for for discretizing any continuous vector <code>v</code>  (<code>scitype(v) &lt;: AbstractVector{Continuous}</code>), where <code>n_classes</code>  describes the resolution of the discretization.</p><p>Transformed output <code>w</code> is a vector of ordered factors (<code>scitype(w) &lt;:  AbstractVector{&lt;:OrderedFactor}</code>). Specifically, <code>w</code> is a  <code>CategoricalVector</code>, with element type  <code>CategoricalValue{R,R}</code>, where <code>R&lt;Unsigned</code> is optimized.</p><p>The transformation is chosen so that the vector on which the  transformer is fit has, in transformed form, an approximately uniform  distribution of values.</p><p><strong>Example</strong></p><pre><code class="language-none">using MLJ
t = UnivariateDiscretizer(n_classes=10)
discretizer = machine(t, randn(1000))
fit!(discretizer)
v = rand(10)
w = transform(discretizer, v)
v_approx = inverse_transform(discretizer, w) # reconstruction of v from w</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MLJModels.FillImputer" href="#MLJModels.FillImputer"><code>MLJModels.FillImputer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FillImputer</p><p>Imputes missing data with a fixed value computed on the non-missing values. The way to compute the filler depends on the scitype of the data and can be specified.</p><p><strong>Fields</strong></p><ul><li><code>continuous_fill</code>:  function to use on Continuous data (by default the median)</li><li><code>count_fill</code>:       function to use on Count data (by default the rounded median)</li><li><code>categorical_fill</code>: function to use on Finite data (by default the mode)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L10">source</a></section><footer><hr/><a class="previous" href="../tuning_models/"><span class="direction">Previous</span><span class="title">Tuning Models</span></a><a class="next" href="../composing_models/"><span class="direction">Next</span><span class="title">Composing Models</span></a></footer></article></body></html>
